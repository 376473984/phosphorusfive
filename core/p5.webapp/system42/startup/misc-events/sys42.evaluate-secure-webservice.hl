
/*
 * Responsible for creating the Active Event that evaluates a cryptographically secure web 
 * service lambda invocation. Will decrypt the given HTTP request, retrieve the first
 * "application/x-hyperlisp" MIME entity, and evaluate it, before encrypting and signing the 
 * result and returning it to caller.
 *
 * Pairs up perfectly with [sys42.invoke-secure-webservice], being the other side of the equation.
 *
 * Only a MIME request, correctly encrypted, and digitally signed, by a PGP private key matching 
 * the list of trusted friends from "/system42/misc/trusted-friends.hl" file will be evaluated. 
 * All other requests will be denied, and thrown  away. In addition, only requests that are 
 * "younger" than whatever can be found in web.config file "webServiceInvocationsFreshTime"
 * will be evaluated, but only if they have not been evaluated before by this server.
 *
 * The result of the evaluation of the specified Hyperlisp, will be encrypted and 
 * cryptographically signed, with private server key, before returned to caller as MIME.
 *
 * Active event takes no arguments, but will automatically decrypt incoming MIME from the current 
 * HTTP response, using the server (Marvin) private PGP key for decryption, and signing results.
 * 
 * The PGP key used to sign the incoming MIME message, will be used for encrypting the returned result
 */

set-protected-event:sys42.evaluate-secure-webservice

  // Retrieving key and password for decrypting MIME entity
  // Later used to sign the result, before returning it to caller
  p5.security.get-marvin-pgp-key
  p5.security.get-marvin-pgp-key-password

  /*
   * Parsing and decrypting incoming MIME message, retrieving the 
   * given Hyperlisp, transforming to lambda, before evaluating lambda
   */
  eval-x:x:/+/**
  p5.web.request.parse-mime
    decryption-keys
      email:x:/../*/p5.security.get-marvin-pgp-key?value
        password:x:/../*/p5.security.get-marvin-pgp-key-password?value

  /*
   * Before we evaluate incoming code, we must make sure
   * it comes from a source we trust, meaning it is cryptographically
   * signed from a person in our "friend list"
   */
  if
    sys42.verify-signature-is-friend:x:/../*/p5.web.request.parse-mime/**/signature/*

    /*
     * Then we need to check the ID and timestamp of message, to ensure same
     * message is not posted twice, and that timestamp is within accepted range,
     * and that invocation has not "expired"
     */
    lisp2lambda:x:/../*/p5.web.request.parse-mime/*/multipart/=encrypted/*/multipart/=mixed/*/application/=x-timestamp/*/content?value
    get-global-value:sys42.evaluated-webservice-ids
    if
      sys42.expired-webservice-invocation:x:/././*/lisp2lambda/*/timestamp?value
      or:x:/./*/get-global-value/*/*/{0}
        :x:/././*/lisp2lambda/*/id?value

      /*
       * Oops, this ID has already been executed before, or request is too old, which indicates 
       * somebody possibly snatched up our entire request, and reposted it, in an attempt at creating
       * confusion! MAJOR SECURITY CONCERN!
       */
      set-http-status-code:500
      set-http-status:500 ID of invocation was reposted or invocation was no longer fresh
      echo:"... does not compute ...!!"
    else

      /*
       * Making sure ID of current invocation is stored to application globals, 
       * to avoid evaluating the same code twice. ORDER COUNTS! Since we want to store
       * the ID before evaluating code, in case evaluated code throws an exception, 
       * at which point code will be possible to evaluate twice, since ID was never stored
       * due to the exception choking the rest of the execution of our event
       */
      add:x:/..if/*/get-global-value/*
        src:@"{0}:date:""{1}"""
          :x:/..if/*/lisp2lambda/*/id?value
          :x:/..if/*/lisp2lambda/*/timestamp?value.string
      add:x:/+/*
        src:x:/..if/*/get-global-value/*/*
      set-global-value:sys42.evaluated-webservice-ids
        src

      /*
       * Now that we have verified that request comes from a source whom
       * we trust, we can evaluate Hyperlisp. Notice, since clone does not
       * do a deep clone of node's values, we need to create some "trickery"
       * here to make sure this event is thread safe, while at the same time
       * make sure we can retrieve the evaluated code's result
       */
      set:x:/..else/*/_eval?value
        src:x:/..else/*/_eval?value.node
      set:x:/..else/*/_eval/#/*
      _eval:
      add:x:/..else/*/_eval/#
        src:x:/../*/p5.web.request.parse-mime/*/multipart/=encrypted/*/multipart/=mixed/*/application/=x-hyperlisp/*/content?value
      eval-mutable:x:/..else/*/_eval/#

      /*
       * Echo results of above evaluation back to caller
       */
      eval-x:x:/..else/*/echo-mime/**
      set:x:/..else/*/echo-mime/*/*/content?value
        src:x:/..else/*/_eval/#/*
      echo-mime
        application:x-hyperlisp
          encryption
            email:x:/../*/p5.web.request.parse-mime/**/signature/*?name
          signature
            email:x:/../*/p5.security.get-marvin-pgp-key?value
              password:x:/../*/p5.security.get-marvin-pgp-key-password?value
          content
  else

    /*
     * Caller was NOT a friend of us!
     */
    set-http-status-code:500
    set-http-status:500 Caller was not a trusted friend of us
    echo:"... does not compute ...!!"

