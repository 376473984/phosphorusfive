
/*
 * Creates the tree widget Active Event, in addition to some helper Active Events.
 */


/*
 * The actual tree widget Active Event.
 * Creates a tree widget, which allows for hierarchically browsing relational tree structures, such as for instance a file
 * system, etc.
 *
 * Tree Widget is "SEO friendly", which means that it will allow spiders to crawl the nodes in your tree, as if they were hyperlinks,
 * while  still remaining the single page app feeling for human users, through Ajax functionality. But only if you explicitly set
 * the [_crawl] paremeter to true. If you do, you can override the default name of the HTTP GET parameter, by supplying it as [_crawl-get-name].
 *
 * Arguments;
 * 
 * [_class]           - CSS class to use, defaults to "tree-widget".
 * [_css-file]        - CSS file to include, defaults to "tree.css" from tree widget's media folder.
 * [_on-get-items]    - Callback lambda evaluated when the tree need more items.
 *                      Callback will be given [_item-id] for which item to retrieve children of.
 *                      Callback is expected to return an [_items] collection, similarly to when the tree is initially created.
 * [_on-select]       - Callback lambda to invoke when an item is selected.
 * [_items]           - Collection of items to show initially as "root items".
 *                      The name of its children nodes is what is displayed to the user, and the value is the "id" of the
 *                      item, used to uniquely identify the item, when the item is clicked for instance, etc.
 * [_crawl]           - If true, the tree will be rendered in SEO mode, meaning that crawling is enabled, through hyperlinks.
 * [_crawl-get-name]  - Allows you to override the default crawling HTTP GET parameter name. Its default value is "sys42_widgets_tree_unroll".
 */
create-event:sys42.widgets.tree

  /*
   * Applying options for widget, with default values.
   */
  _defaults
    _class:tree-widget
    _css-file:/system42/components/tree-widget/media/tree.css
    _on-get-items
      sys42.windows.info-top:You should really have supplied an [_on-get-items] callback! If not for anything else, than to make it empty!
        _class:info-window info-window-longer info-window-error
    _on-select
      sys42.windows.info-top:You should really have supplied an [_on-select] callback! If not for anything else, than to make it empty!
        _class:info-window info-window-longer info-window-error
    _crawl-get-name:sys42_widgets_tree_unroll
    _crawl:bool:false
  _options
  add:x:/../*/_options
    src:x:@"(/../*/"":regex:/^_/""|/../*/_defaults/*)(!/_defaults!/_options)/$"


  /*
   * Making sure we include our tree specific CSS file.
   */
  include-stylesheet-file:x:/../*/_options/*/_css-file?value


  /*
   * Adding initial items recursively to return widget.
   */
  eval-x:x:/+/*/*
  add:x:/../*/return/*/container/*/widgets
    sys42.widgets.tree._create-items
      _items:x:/../*/_options/*/_items


  /*
   * Adding [_on-get-items] callback into [sys42.widgets.tree._get-items]
   */
  add:x:/../*/return/*/*/events/*/sys42.widgets.tree._get-items
    src:x:/../*/_options/*/_on-get-items/*


  /*
   * Adding [_on-select] callback into [sys42.widgets.tree._select]
   */
  add:x:/../*/return/*/*/events/*/sys42.widgets.tree._select
    src:x:/../*/_options/*/_on-select/*


  /*
   * Removing the [oninit] of widget, if crawling is disabled.
   */
  if:x:/../*/_options/*/_crawl?value.bool
    not
    set:x:/../*/return/*/*/oninit
  else
    set:x:/../*/return/*/*/_root-tree?value
      src:x:/../*/_options/*/_crawl-get-name?value


  /*
   * Forward evaluating [class] to make sure we use [_options]/[_class] if supplied.
   */
  eval-x:x:/../*/return/*/*/class


  /*
   * Returning widget to caller.
   */
  return
    container


      /*
       * Used to track the "root widget" for our tree, such that we can easily retrieve it, 
       * using [find-first-ancestor-widget] later.
       */
      _root-tree


      /*
       * Forward evaluated before [return] invocation, to [_options]/[_class] value.
       */
      class:x:/../*/_options/*/_class?value


      /*
       * Events for tree widget.
       */
      events


        /*
         * Invoked when tree needs to retrieve children items for a specific tree node.
         * The lambda for this event, is created from the [_on-get-items] callback supplied during creation of tree.
         */
        sys42.widgets.tree._get-items

          /*
           * First we must make sure this is the tree requested by caller to toggle items within.
           */
          if:x:/../*/_arg?value
            !=:x:/../*/_event?value

            /*
             * This is NOT our tree.
             * Returning early, before callback lambda is evaluated.
             */
            return

          /*
           * Notice, the rest of this Active Event is dynamically created according to arguments supplied when
           * creating the tree, by invoking [add] to append user supplied lambda callback into body of this lambda.
           * Hence, it might appear to be empty, but it is probably not in fact.
           */


        /*
         * Invoked when items are selected in tree widget.
         */
        sys42.widgets.tree._select

          /*
           * First we must make sure this is the tree requested by caller to toggle items within.
           */
          if:x:/../*/_arg?value
            !=:x:/../*/_event?value

            /*
             * This is NOT our tree.
             * Returning early, before callback lambda is evaluated.
             */
            return

          /*
           * Notice, the rest of this Active Event is dynamically created according to arguments supplied when
           * creating the tree, by invoking [add] to append user supplied lambda callback into body of this lambda.
           * Hence, it might appear to be empty, but it is probably not in fact.
           */


        /*
         * Invoked when an item is "selected".
         *
         * [_arg] must be the ID of the main tree widget.
         * [_items] must be a collection of items to select.
         *
         * Notice, all previously selected items are de-selected!
         */
        sys42.widgets.tree.select-items

          /*
           * First we must make sure this is the tree requested by caller.
           */
          if:x:/../*/_arg?value
            =:x:/../*/_event?value

            /*
             * This is the tree caller requested to select items in, 
             * first finding all previously selected items, and de-selecting them.
             */
            find-widget-like:x:/../*/_event?value
              class:tree-selected
            if:x:/-/*?count
              !=:int:0

              /*
               * Tree has previously selected items, making sure we un-select them.
               */
              sys42.delete-css-classes:x:/./-/*?value
                _class:tree-selected

            /*
             * Then adding the selected CSS class to all items requested by caller.
             */
            for-each:x:/../*/_items/*?name
              find-widget:x:/../*/_event?value
                _item-id:x:/..for-each/*/_dp?value
              find-widget:x:/-/*?value
                element:a
              sys42.add-css-classes:x:/-/0?value
                _class:tree-selected

            /*
             * Making sure [_on-select] lambda callback is invoked.
             */
            add:x:/+
              src:x:/../*/_items
            sys42.widgets.tree._select:x:/../*/_arg?value


        /*
         * Invoked when user wants to "toggle" one or more items.
         * Expects [_items] collection.
         */
        sys42.widgets.tree.toggle-items

          /*
           * First we must make sure this is the tree requested by caller to toggle items within.
           */
          if:x:/../*/_arg?value
            =:x:/../*/_event?value

            /*
             * This is the tree caller requested to have items toggled in, 
             * now looping through all [_items] caller wants to toggle.
             */
            for-each:x:/../*/_items/*?name

              /*
               * Finding anchor/hyperlink for currently iterated item, then retrieving its parent, 
               * for then to find its parent's "ul" widget, if it exist.
               */
              find-widget:x:/../*/_event?value
                _item-id:x:/..for-each/*/_dp?value
              if:x:/..for-each/*/find-widget/*?value
                not

                /*
                 * Caller supplied a non-existing item.
                 */
                throw:Oops, that item doesn't exist!

              /*
               * Now checking if there already exist a "ul" HTML widget beneath the main "tree-item".
               * If a "ul" widget exist, we delete it, if not, we invoke the lambda callback provided during creation,
               * to retrieve additional items, before we create it (the "ul" widget).
               *
               * Notice, deletion can be prevented by adding the [_no-delete] argument set to true.
               */
              get-children-widgets:x:/..for-each/*/find-widget/*?value
              if:x:/-/*/*/container

                /*
                 * Checking if caller did not want items deleted to "force open".
                 */
                if:x:/../*/_no-delete?value
                  not

                  /*
                   * Children items are already visible, and caller did not want to "force open", hence deleting items.
                   */
                  delete-widget:x:/..for-each/*/get-children-widgets/*/*/container?value

                  /*
                   * Removing the "expanded" CSS class on parent widget.
                   */
                  sys42.delete-css-classes:x:/..for-each/*/find-widget/*?value
                    _class:tree-expanded
              else

                /*
                 * Children items are NOT visible, requesting them through lambda callback supplied during creation, 
                 * and creating widgets from these items.
                 */
                eval-x:x:/+/*
                sys42.widgets.tree._get-items:x:/../*/_arg?value
                  _item-id:x:/..for-each/*/_dp?value

                /*
                 * Making sure this item actually has children items, and if not, returning to avoid changing CSS class,
                 * and do redundant work.
                 */
                if:x:/-/*/_items/*
                  not
                  return

                /*
                 * Then evaluating Active Event responsible for creating widgets out of our returned [_items] collection,
                 * from the above [sys42.widgets.tree._get-items] invocation.
                 *
                 * Notice, we pass in the node to our [_items] by reference, as value of the [_items] node argument.
                 */
                eval-x:x:/+/*
                sys42.widgets.tree._create-items
                  _items:x:/..else/*/sys42.widgets.tree._get-items/*/_items

                /*
                 * Making sure we change the returned [ul] to a [create-container-widget] invocation.
                 */
                set:x:/..else/*/sys42.widgets.tree._create-items/0?name
                  src:create-container-widget

                /*
                 * Making sure we add "ul" as value of [element] to [create-container-widget] invocation, in addition
                 * to making sure our "ul" widget gets the correct [parent] argument, which is the parent "li" element.
                 */
                eval-x:x:/+/*/*
                add:x:/..else/*/sys42.widgets.tree._create-items/0
                  src
                    element:ul
                    parent:x:/..for-each/*/find-widget/*?value

                /*
                 * Making sure we add the "tree-item-children-animate" CSS class to our widget, since this is
                 * a dynamically created child control collection. To create some nice animations, as the items shows
                 * up on page initially.
                 */
                set:x:/..else/*/sys42.widgets.tree._create-items/*/*/class?value
                  src:tree-item-children tree-item-children-animate

                /*
                 * Now we can simply [eval] the returned lambda from the above [sys42.widgets.tree._create-items] invocation,
                 * since it is now a [create-container-widget] invocation, correctly creating items, appending to tree item,
                 * specified in currently iterated [_items] argument.
                 */
                eval:x:/..else/*/sys42.widgets.tree._create-items

                /*
                 * Adding the "expanded" CSS class in parent widget.
                 */
                sys42.add-css-classes:x:/..for-each/*/find-widget/*?value
                  _class:tree-expanded

      /*
       * Checking if we should "unroll items".
       */
      oninit

        /*
         * Checking URL to determine if we should "unroll" items.
         */
        get-widget-property:x:/../*/_event?value
          _root-tree
        get-http-get-param:x:/-/*/*?value
        if:x:/../*/get-http-get-param/*?value
          not

          /*
           * Nothing to do here.
           */
          return

        /*
         * Splitting up every ID from URL, and adding every ID to invocation of [toggle-items] forcing "unrolling" through [_no-delete].
         */
        split:x:/../*/get-http-get-param/*?value
          =:|
        add:x:/+/*/_items
          src:x:/../*/split/*?name
        sys42.widgets.tree.toggle-items:x:/../*/_event?value
          _items
          _no-delete:bool:true

        /*
         * Making sure we select outer most item.
         */
        add:x:/../*/sys42.widgets.tree.select-items/*
          src:x:/../*/split/0/-?name
        sys42.widgets.tree.select-items:x:/../*/_event?value
          _items
      widgets


/*
 * Supporting Active Event, to create items.
 * Used both during initial creation of tree widget, to create initially shown nodes, and during 
 * "toggling" (creation of new items).
 */
create-event:sys42.widgets.tree._create-items

  /*
   * Checking if we have items, and if not, returning early.
   */
  if:x:/../*/_items/#/*
    not
    return

  /*
   * Looping through all [_items]
   */
  for-each:x:/../*/_items/#/*

    /*
     * Forward evaluating [_items] collection in recursive invocation of "self" inside of [add], to make sure
     * we recursively add children [_items] of currently iterated [_items].
     *
     * This allows us to create hierarchies of items, both during initial creation, and during toggling/expanding of items.
     */
    eval-x:x:/+/*/*
    add:x:/..for-each/*/add/[1,2]/*/*/*/widgets
      sys42.widgets.tree._create-items
        _items:x:/..for-each/*/_dp/#/*/_items
        _nested:bool:true

    /*
     * Checking if this is a [_nested] item, at which case, we should add the "tree-expanded" CSS class to "li" HTML widget.
     */
    if:x:/../*/_nested?value
      set:x:/..for-each/*/add/[1,2]/*/*/*/class?value
        src:{0} tree-expanded
          :x:/..for-each/*/add/[1,2]/*/*/*/class?value

    /*
     * Setting properties for currently iterated item, and adding item into [return] below.
     *
     * These are simply [innerValue] on hyperlink, in addition to [_item-id] on "li", which is a server-side hidden property
     * for the item, allowing us to figure out the "id" of which item was clicked, among other things.
     */
    eval-x:x:/..for-each/*/add/[1,2]/*/*/*(/_item-id|/*/a/*/innerValue)

    /*
     * Adding currently iterated [_items] to [return] below, now with the correct [innerValue] and [_item-id] according
     * to caller's request.
     */
    add:x:/../*/return/*/*
      src
        li
          class:tree-item
          _item-id:x:/..for-each/*/_dp/#?value
          widgets
            a
              href:#
              role:button
              class:tree-item-label
              innerValue:x:/..for-each/*/_dp/#?name
              onclick

                /*
                 * Getting id of item, and passing into [toggle-items] and [select-items] as [_items] collection.
                 */
                get-parent-widget:x:/../*/_event?value
                get-widget-property:x:/-/*/*?value
                  _item-id
                add:x:/../*/sys42.widgets.tree.toggle-items/*|/../*/sys42.widgets.tree.select-items/*
                  src:x:/../*/get-widget-property/*/*?value

                /*
                 * The finding "root tree" widget for currently clicked item, such that we can pass it
                 * into [toggle-items] and [select-items].
                 */
                find-first-ancestor-widget:x:/../*/_event?value
                  _root-tree
                sys42.widgets.tree.toggle-items:x:/../*/find-first-ancestor-widget/*?value
                  _items
                sys42.widgets.tree.select-items:x:/../*/find-first-ancestor-widget/*?value
                  _items

              /*
               * To make sure we are able to create our SEO URL in hyperlink, we handle [oninit],
               * since at that point, the widget is "rooted", and we can traverse all "li" elements
               * upwards in hierarchy, all the way to the "root" widget, to retrieve all IDs of elements.
               */
              oninit

                /*
                 * Retrieving parent "li" HTML widget, and passing it into [_create-url], which will
                 * traverse the hierarchy upwards, adding all necessary IDs, and creating a URL that will
                 * expand all items leading to "current item".
                 */
                find-first-ancestor-widget:x:/../*/_event?value
                  _root-tree
                get-widget-property:x:/-/*?value
                  _root-tree
                if:x:/-/*/*?value
                  get-parent-widget:x:/../*/_event?value
                  sys42.widgets.tree._create-url:x:/-/*/*?value
                  set-widget-property:x:/../*/_event?value
                    href:x:/..if/*/sys42.widgets.tree._create-url?value

  /*
   * Returning widget hierarchy.
   */
  return
    ul
      class:tree-item-children
      widgets


/*
 * Supporting Active Event, to create URL from given [_arg] "li" widget.
 */
create-event:sys42.widgets.tree._create-url

  /*
   * First we get current location, without GET parameters, before we add the question mark to make sure we 
   * "open" our GET params collection.
   */
  get-location-url
  set:x:/../*/get-location-url?value
    src:{0}?
      :x:/../*/get-location-url?value

  /*
   * Then we must fetch all GET parameters, and remove any previously created "sys42_widgets_tree_unroll" params,
   * before we add all other GET parameters, to make sure we keep everything EXCEPT "sys42_widgets_tree_unroll".
   */
  find-first-ancestor-widget:x:/../*/_arg?value
    _root-tree
  get-widget-property:x:/-/*?value
    _root-tree
  list-http-get-params
  set:x:/-/*/{0}
    :x:/../*/get-widget-property/*/*?value
  if:x:/-2/*
    get-http-get-param:x:/./-2/*?name
    for-each:x:/-/*
      url-encode:x:/./*/_dp/#?value
      set:x:/../*/get-location-url?value
        src:{0}{1}={2}&
          :x:/../*/get-location-url?value
          :x:/..for-each/*/_dp/#?name
          :x:/..for-each/*/url-encode?value

  /*
   * Adding key for our "unroll" GET parameter.
   */
  set:x:/../*/get-location-url?value
    src:{0}{1}=
      :x:/../*/get-location-url?value
      :x:/../*/get-widget-property/*/*?value

  /*
   * Then we need to recursively iterate from current widget, and upwards in hierarchy, until
   * we reach "main root tree widget", and append all IDs to the URL separated by a pipe sign (|).
   * Making sure we url-encode the whole thing, before adding it.
   */
  set:x:/+?value
    src:x:/../*/_arg?value
  _cur
  _param
  while:bool:true
    get-widget-property:x:/../*/_cur?value
      _item-id
    set:x:/../*/_param?value
      src:{0}|{1}
        :x:/..while/*/get-widget-property/[0,1]/*/*?value
        :x:/../*/_param?value
    get-parent-widget:x:/../*/_cur?value
    get-parent-widget:x:/-/*/*?value

    /*
     * Checking if we're done. Unless current widget is an "li" widget, we're at the
     * root widget for our tree widget.
     */
    get-widget-property:x:/-/*/*?value
      element
    if:x:/-/*/*?value
      !=:li

      // This is main root tree widget, which is "div" and not "li".
      break
    set:x:/../*/_cur?value
      src:x:/..while/*/get-parent-widget/[1,2]/*/*?value

  /*
   * Now we URL encode entire parameter, before we return it concatenated with base URL to caller.
   */
  trim:x:/../*/_param?value
    chars:|
  url-encode:x:/../*/trim?value

  return:{0}{1}
    :x:/../*/get-location-url?value
    :x:/../*/url-encode?value
