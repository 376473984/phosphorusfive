
/*
 * Creates the Active Event that shows the user a modal window, asking user for some input.
 *
 * Arguments;
 * 
 * [_header]         - Header of modal dialogue
 * [_body]           - Explanatory text of dialogue
 * [_class]          - Override the default CSS class
 * [_inner-class]    - Override the default inner CSS class. Set this to "modal-dialog modal-lg" to create a wider dialogue.
 * [_buttons]        - Makes it possible to exchange the default "OK" button with your own buttons
 *                     If you supply a [_buttons] parameter, then [_ok] has no effect, and you must
 *                     provide your own logic in the onclick handler of these buttons instead.
 *                     To evaluate the [.onok] lambda, you can invoke [sys42.windows.modal.ok],
 *                     To close dialogue, you can invoke [sys42.windows.modal.destroy]. If you wish to
 *                     make sure your [.oncancel] lambda is evaluated, you should use [sys42.windows.modal.cancel]
 *                     instead. [sys42.windows.modal.destroy] will not evaluate your [.oncancel] lambda callback.
 * [_data]           - Will automatically create a widget collection, according to the type of data supplied.
 *                     The default widget type to use, is a normal textbox. However, if you supply a child node with the name of
 *                     [_options], it will create a select HTML element instead, with the option elements supplied as children of [_options].
 * [.onok]           - Code to be evaluated if user clicks OK button
 * [.oncancel]       - Lambda callback to be evaluated if user closes dialogue without pressing "OK".
 *
 * If user closes modal dialogue, without clicking OK, then the given [.onok] is not evaluated.
 * There can be only one instance of this window at the same time in your page.
 */
create-event:sys42.windows.wizard

  /*
   * Simply using the [sys42.windows.modal] to create our wizard window.
   * First applying all arguments into [.lambda], which contains our [sys42.windows.modal] invocation.
   */
  add:x:/../*/.lambda/*
    src:x:/./--

  /*
   * Sanity checking arguments.
   */
  if:x:/../*/_header?value
    not
    add:x:/../*/.lambda/*
      src
        _header:Please supply input!
  if:x:/../*/_body
    not
    add:x:/../*/.lambda/*
      src
        _body:<p>Please supply me with some input</p>
  if:x:/../*/_widgets
    throw:You cannot supply a [_widgets] collection to [sys42.windows.wizard]. Use [sys42.windows.modal] instead.

  /*
   * Looping through each [_data] items, creating an edit widget for each item.
   *
   * Notice, by default, this creates a textbox "input" HTML widget for each child node of [_data], unless the node contains an [_options] child,
   * at which case it will create a "select" HTML widget instead, with the currently active value, being the value of the currently iterated
   * [_data] child.
   */
  for-each:x:/../*/_data/*

    /*
     * Checking what type of edit field this is.
     */
    if:x:/@_dp/#/*/_options

      /*
       * Select dropdown choices.
       * Creating our "option" widgets through a lambda callback, which will return the [value] and [innerValue] for the currently
       * iterated "option" element. Making sure we set the [_selected] value for our "select" widget, inside of our lambda, such that
       * it can check if currently iterated "option" element is the initially selected option.
       */
      set:x:/+/*/_selected?value
        src:x:/@_dp/#?value

      /*
       * Used as a lambda callback for our [apply] invocation below.
       */
      _eval-option
        _selected

        /*
         * Returning [value] and [innerValue] to caller.
         */
        eval-x:x:/+/*/*
        add:x:/../*/return
          src
            value:x:/@_dn/#?value
            innerValue:x:/@_dn/#?name

        /*
         * Checking if currently iterated "option" element is selected, and if so, adding [selected] attribute to return lambda.
         */
        if:x:/../*/_selected?value
          =:x:/../*/_dn/#?value
          add:x:/../*/return
            src:selected

        /*
         * Returning [value], [innerValue] and possibly also [selected] to caller, which is our [apply] below.
         */
        return

      /*
       * Using [apply] to create our "option" HTML widgets, and append into [widgets] of [select] below.
       */
      apply:x:/+2/**/select/*/widgets
        src:x:/@_dp/#/*/_options/*
        template
          option
            {@eval}:x:/..if/*/_eval-option

      /*
       * Forward evaluating other arguments.
       */
      eval-x:x:/+/**(/label|/select)/*
      add:x:/../*/.lambda/*/sys42.windows.modal/*/_widgets
        src
          container
            class:form-group
            widgets
              container
                class:input-group
                widgets
                  label
                    class:input-group-addon
                    innerValue:x:/@_dp/#?name
                  select
                    class:form-control
                    value:x:/@_dp/#?value
                    _data-field-name:x:/@_dp/#?name
                    widgets

    else

      /*
       * Defaulting to "textbox".
       */
      eval-x:x:/+/**(/label|/input)/*
      add:x:/../*/.lambda/*/sys42.windows.modal/*/_widgets
        src
          container
            class:form-group
            widgets
              container
                class:input-group
                widgets
                  label
                    class:input-group-addon
                    innerValue:x:/@_dp/#?name
                  input
                    type:text
                    class:form-control
                    value:x:/@_dp/#?value
                    _data-field-name:x:/@_dp/#?name

    /*
     * Making sure we set initial focus to the first widget in our [_widgets] collection.
     */
    if:x:/../*/.lambda/*/sys42.windows.modal/*/_widgets/*?count
      >:int:0

      /*
       * There exists a [_widgets] collection in invocation to [sys42.windows.modal].
       *
       * Making sure we give initial focus to first widget automatically.
       */
      add:x:/../*/.lambda/*/sys42.windows.modal/*/_widgets/0/*/widgets/0/*/widgets/1
        src
          oninit
            sys42.windows.modal.initial-focus:x:/../*/_event?value

  /*
   * Now we can evaluate our modal window, with a dynamically built [_widgets] collection, created above.
   */
  .lambda
    sys42.windows.modal
      _widgets
  eval:x:/@.lambda

  /*
   * Making sure we create our data-retrieval Active Event, after creation of modal window, and associate it with our modal window.
   */
  set-widget-lambda-event:sys42-windows-modal

    /*
     * This becomes an easy way to retrieve the supplied values from our wizard window.
     */
    sys42.windows.wizard.get-values

      /*
       * Finding all data-fields in modal window.
       */
      find-widget:sys42-windows-modal
        _data-field-name

      /*
       * Retrieving their data-field names and values.
       */
      get-widget-property:x:/@find-widget/*/*?value
        _data-field-name
        value
      for-each:x:/@get-widget-property/*
        add:x:/../*/return
          src:@"{0}:@""{1}"""
            :x:/@_dp/#/*/_data-field-name?value
            :x:/@_dp/#/*/value?value
      return
